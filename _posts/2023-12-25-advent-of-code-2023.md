---
layout: post
title: "Advent of Code 2023"
date: 2023-12-01
---

{% include mathjax.html %}

That time of year again, it's time for [Advent of Code](https://adventofcode.com/2023/).
Again I will be writing my solutions in Common Lisp and writing about them here.

## Day 1: Trebuchet?!

For the first part you are given a bunch of lines containing letters and numbers.
Each line will always contain at least one digit.
For each line we have to combine the digit that appears first (the leftmost digit) with the digit that appears last (the rightmost digit) into a single number, and then sum all these numbers together over each line.
Not too bad, I used the following simple loop:

```common-lisp
(loop for line in (read-from-file filename)
      for digits = (mapcar #'digit-char-p (remove-if-not #'digit-char-p (coerce line 'list)))
      for ldigit = (first digits) and rdigit = (first (last digits))
      sum (+ (* 10 ldigit) rdigit))
```

Now for the second part it turns out that each line contains _descriptions_ of digits, where this description can either be the digit itself or the word, i.e., "one", "two", "three", etc.
Again we have to combine the leftmost digit with the rightmost in each line and sum these together.
I defined an association list mapping strings to numerical values, so for example `values["six"] == values["6"] == 6`, and then for each line I checked if each digit description ("one", "1", "two", "2", "three", "3", ...) appeared in the line.
Something that caught me out was that `(search digit-description line)` only return the index of the _first_ match in the line, meaning descriptions that appeared multiple times in the same line were being ignored, which was important to find the rightmost description in the line.
I fixed this by simply searching, for each line, the original line for the earliest description of a digit to obtain the leftmost digit, and then _reversing the line_ and searching for the _reversal_ of each number description to obtain the rightmost digit.
Here is the code.
It uses `search-leftmost-description` to find the leftmost digit description, and `search-rightmost-description` is implemented by simply reversing the `line` and `descriptions` parameters and calling `search-leftmost-description`.
We are then left with a string description for a number, which we convert to a number using the helper function `description->digit`, which simply uses the association list (dictionary) to convert a string description to a number.

```common-lisp
(let ((descriptions '("one" "two" "three" "four" "five" "six" "seven" "eight" "nine" "1" "2" "3" "4" "5" "6" "7" "8" "9")))
  (loop for line in (read-from-file filename)
        for ldigit = (description->digit (search-leftmost-description line descriptions))
        for rdigit = (description->digit (reverse (search-rightmost-description line descriptions)))
        for number = (+ (* 10 ldigit) rdigit)
        sum number))
```

## Day 2: Cube Conundrum

Today's puzzle has us talking to an elf that is pulling some coloured balls out a bag.
The balls can be red, green, or blue, and the puzzle's input details how many balls of each colour the elf pulls out each round for a number of rounds.
The elf wants to know which rounds would have been possible if the bag contained only 12 red, 13 green, and 14 blue balls to begin with.
Here, a game is possible if the number of balls of each colour that are pulled out of the bag in a round never exceed the number of balls in the bag (12 for red, 13 for green, 14 for blue).
The approach is simple, just iterate over the rounds and check which games are possible.
I first wrote a helper function `(subgame-total-color-balls subgame color)` which counts the number of `colour` balls in `subgame`.
Really this just hides an association list access, where the value associated with a given key `color` is the number of balls of type `color` removed from the bag in the given round of the game.
I then used this to write another helper function `(game-possible-for-color-p subgames color totals)` which simply checks that for each round in a game the number of `color` balls removed from the bag does not exceed the maximum in `totals`.

```common-lisp
(defun game-possible-for-color-p (subgames color totals)
  (every (lambda (subgame)
           (<= (subgame-total-color-balls subgame color)
               (subgame-total-color-balls totals color)))
         subgames))
```

Then it is simply a case of going over each game and checking that the game is possible for each colour ball.
The final answer is to sum the game ID for each game that is possible for all colours.

```common-lisp
(loop with totals = '(("red" . 12) ("green" . 13) ("blue" . 14))
      with colors = '("red" "green" "blue")
      for line in (read-from-file filename)
      for subgames = (mapcar #'parse-subgame (ppcre:split ";" line))
      for i from 1
      if (every (lambda (color) (game-possible-for-color-p subgames color totals)) colors)
        sum i)
```

For the second part we want to find the minimum number of balls required of each colour that would make each game possible.
To tackle this we can simply take the maximum number of balls removed taken out of the bag for each colour (since we know we need at least this many balls in the bag of this colour for the game to be possible).
As per the puzzle we then have to multiply these minimums together for each colour per game and sum the resulting value over all games given in the input.

```common-lisp
(loop with colors = '("red" "green" "blue")
      for line in (read-from-file filename)
      for subgames = (mapcar #'parse-subgame (ppcre:split ";" line))
      for minimums = (mapcar (lambda (color)
                               (reduce #'max (mapcar (lambda (subgame)
                                                       (subgame-total-color-balls subgame color))
                                                     subgames)))
                             colors)
      sum (reduce #'* minimums))
```

I faffed about on this with the helper functions but hopefully it ended up in slightly more readable code.
I learned that using `(assoc key alist)` to access the value corresponding to the key in the association list will return the entire entry/dotted pair upon success, so to get the actual value you have to use `(rest (assoc key alist))`, which tripped me up a few times.
